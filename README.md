# Software-Observability

**What are Logs?**

<h2>Logs</h2>

<p>
Logs contain <strong>plain text or JSON</strong> to record events that occur during the processing of an
<strong>API request</strong> within an application.
</p>

<h3>Why Logs Are Important</h3>

<p>Logs can record the following levels:</p>

<ul>
  <li><strong>Information</strong></li>
  <li><strong>Warning</strong></li>
  <li><strong>Error</strong></li>
</ul>

<p>These are crucial for:</p>

<ul>
  <li>
    <strong>Debugging</strong> — understanding what happened within the application while processing an API request.
  </li>
  <li>
    <strong>Tracking errors and failures</strong> along with stack traces.
  </li>
  <li>
    <strong>Monitoring application behavior</strong> to detect unusual patterns.
  </li>
</ul>

<h3>API-Level Details Captured in Logs</h3>

<ul>
  <li>
    <strong>Incoming request details</strong>
    <ul>
      <li>URL</li>
      <li>HTTP method</li>
      <li>Headers</li>
      <li>Request body</li>
    </ul>
  </li>
  <li>
    <strong>Events occurring during API request processing</strong>
  </li>
  <li>
    <strong>Outgoing response details</strong>
    <ul>
      <li>Status code</li>
      <li>Time taken</li>
      <li>Response payload</li>
    </ul>
  </li>
</ul>

<h2>Limitation</h2>

<ul>
  <li>
    <strong>Logs</strong> do not show the <strong>API request end-to-end journey</strong> across microservices.
  </li>
  <li>
    We don’t know the <strong>time breakdown per service</strong>, which helps us understand where the request spent more time.
  </li>
</ul>

<p>
If a request goes through:
<strong>OrderService → PaymentService</strong>
</p>

<p>
Each application maintains its logs <strong>independently</strong>.
</p>

<pre>
[OrderService] Order created for userId=55
</pre>

<p>Similarly:</p>

<pre>
[PaymentService] Payment timeout userId=55
</pre>

<p>
But we can’t easily <strong>tie these logs together</strong> (for example, whether both logs belong to the same API request)
or determine <strong>how long each step took</strong>.
</p>

<img width="1378" height="670" alt="image" src="https://github.com/user-attachments/assets/46c03387-485c-44c1-b118-4fdf4dd7ac91" />

<h2>Tracing</h2>

<ul>
  <li>
    <strong>Tracing</strong> tracks the path of a request across <strong>microservices</strong>.
  </li>
</ul>

<p><strong>It shows high-level information such as:</strong></p>

<ul>
  <li>Which service called which service</li>
  <li>How much time each service took</li>
  <li>Status code of each service (200, 400, 500, etc.)</li>
</ul>

<p>
<strong>But tracing does NOT store detailed logs.</strong>
</p>

<h2>How Distributed Tracing Works</h2>

<p>
To achieve this, <strong>Distributed Tracing</strong> creates
<strong>TRACE_ID</strong> and <strong>SPAN_ID</strong>.
</p>

<ul>
  <li>
    <strong>Trace ID</strong>:
    Connects a request across multiple microservices using
    <strong>one unique identifier</strong>.
  </li>
</ul>

<ul>
  <li>
    <strong>Span ID</strong>:
    Each service has its own unique <strong>Span ID</strong>, which represents
    individual units of work performed inside that service.
  </li>
</ul>

<p>Let's say everything in here is a synchronous call. Service A is waiting till all the internal processes are done and response can be returned from Service A's end. So, we now know which serivce took how much time.</p>

<img width="1577" height="676" alt="image" src="https://github.com/user-attachments/assets/bf79c3e4-47ca-4cb2-b507-b124c55b008f" />

<p>We can make our own custom span and inside that a child span, just to know when the a particular operation started and when it ended. A child span will be part of parent span means task inside a task and how much time it took for that child task to execute will be observed with the help of child span.</p>

 <strong>In general, below mentioned are the cases for which Springboot microserivce internally creates a new span</strong>:

<ul>
  <li>When we have <strong>an incoming request</strong> to an application.</li>
    <li>When we create <strong>a new thread or thread handof</strong>.</li>
      <li>Within an application (When having atleast two application) <strong>trying to invoke a second application</strong> so for a duration from when the request initiated for invoking the second application till the response is returned</li>
</ul>

<img width="1307" height="303" alt="image" src="https://github.com/user-attachments/assets/5a733a3f-0b80-46e3-8026-956aefca25f0" />

<h2>Note</h2>

<p>
A modern <strong>distributed logging system</strong> uses the
<strong>Trace ID</strong> generated by <strong>distributed tracing</strong>
to stitch together logs from multiple microservices that belong to the
<strong>same API request</strong>.
</p>

<p>
If a request flows through:
<strong>OrderService → PaymentService</strong>
</p>

<p>
Each application maintains its logs <strong>independently</strong>, but the logs
are stitched together using a <strong>unique and common Trace ID</strong>.
</p>

<pre>
TRACE-ID=T123 [OrderService] Order created for userId=55
</pre>

<p>Similarly:</p>

<pre>
TRACE-ID=T123 [PaymentService] Payment timeout userId=55
</pre>

<p>
Even though these are <strong>separate logs</strong> from different services,
they can be combined in tools like <strong>Kibana</strong> or
<strong>CloudWatch</strong>.
</p>

<p>
For example, when we search using
<strong>traceId = T123</strong>, all related logs from different services involved
in a single API request appear together.
</p>
<h2>Old / Legacy Flow</h2>

<ul>
  <li>
    Uses <strong>Spring Cloud Sleuth</strong>, which relies on the
    <strong>Brave</strong> library and is compatible with the
    <strong>Zipkin</strong> backend service.
  </li>
  <li>
    Supporting other backend services like <strong>Jaeger</strong> is
    <strong>not straightforward</strong> and may require additional
    configuration hacks.
  </li>
</ul>

<img width="1141" height="373" alt="image" src="https://github.com/user-attachments/assets/43f80169-f9a5-4a19-bbac-bbb4a66ab9b6" />

<h2>Distributed Tracing with Spring Cloud Sleuth and Zipkin</h2>

<p>
When a new API request enters the system, <strong>Spring Cloud Sleuth</strong>
automatically takes responsibility for generating all the required tracing
information.
</p>

<h3>Trace and Span Generation</h3>

<p>
For every fresh request, Sleuth generates a <strong>Trace ID</strong> and an
initial <strong>Span ID</strong>.
</p>

<ul>
  <li>
    The <strong>Trace ID</strong> uniquely identifies the request across all
    microservices.
  </li>
  <li>
    The <strong>Span ID</strong> represents a single unit of work within a
    service.
  </li>
</ul>

<p>
As the request propagates to downstream microservices, Sleuth automatically
adds the <strong>Trace ID</strong> and <strong>Parent Span ID</strong> to the
<strong>request headers</strong>.
</p>

<p>
This ensures that:
</p>

<ul>
  <li>The downstream service does <strong>not generate a new Trace ID</strong></li>
  <li>The new span is correctly linked to its <strong>parent span</strong></li>
  <li>The complete request flow remains connected across services</li>
</ul>

<h3>Span Lifecycle</h3>

<p>
Each service creates its own span to represent the work it performs.
Every span contains at least the following information:
</p>

<ul>
  <li><strong>Trace ID</strong></li>
  <li><strong>Span ID</strong></li>
  <li><strong>Parent Span ID</strong></li>
</ul>

<p>
In addition to these, spans can include extra metadata such as:
</p>

<ul>
  <li>Request URL</li>
  <li>HTTP method</li>
  <li>Service name</li>
  <li>Execution time</li>
  <li>Error details (if any)</li>
</ul>

<p>
Once a span is completed, <strong>Spring Cloud Sleuth</strong> places it into an
<strong>asynchronous in-memory queue</strong>.  
This process is handled internally by Sleuth to avoid blocking the main
request flow.
</p>

<h3>Zipkin Exporter</h3>

<p>
The <strong>Zipkin Exporter</strong> is responsible for sending completed spans
from the in-memory queue to the <strong>Zipkin backend</strong>.
</p>

<p>
It exports span data asynchronously, ensuring minimal performance impact on
the application.
</p>

<h3>Zipkin Backend</h3>

<p>
The <strong>Zipkin backend</strong> receives span data from multiple services
and builds a <strong>tree-like structure</strong> by stitching together
<strong>Trace IDs</strong> and <strong>Span IDs</strong>.
</p>

<p>
This stitched view allows Zipkin to:
</p>

<ul>
  <li>Visualize the complete request flow across microservices</li>
  <li>Show parent-child relationships between spans</li>
  <li>Display latency and timing information for each service</li>
  <li>Help identify bottlenecks and failures</li>
</ul>

<p>
Apart from Zipkin, other observability tools such as
<strong>Grafana</strong> can also be used for visualization and monitoring,
depending on the tracing backend and setup.
</p>
<h2>Distributed Tracing – Diagram Friendly Explanation</h2>

<p>
Distributed Tracing tracks the complete journey of an API request as it flows
through multiple microservices using a <strong>Trace ID</strong> and
<strong>Span IDs</strong>.
</p>

<h3>High-Level Flow</h3>

<pre>
Client Request
      |
      v
+----------------+
| Order Service  |
| Trace ID: T1   |
| Span ID: S1    |
+----------------+
      |
      v
+-------------------+
| Payment Service   |
| Trace ID: T1      |
| Span ID: S2       |
| Parent: S1        |
+-------------------+
      |
      v
+-------------------+
| Inventory Service |
| Trace ID: T1      |
| Span ID: S3       |
| Parent: S2        |
+-------------------+
</pre>

<p>
All services share the <strong>same Trace ID</strong>, but each service creates
its own <strong>Span ID</strong> to represent the work it performs.
</p>

---

<h2>Step-by-Step Request Flow Example</h2>

<h3>Step 1: Client Sends Request</h3>

<p>
A client sends a request to the <strong>Order Service</strong>.
Since this is a new request, <strong>Spring Cloud Sleuth</strong> generates:
</p>

<ul>
  <li>A new <strong>Trace ID</strong> (example: <code>T123</code>)</li>
  <li>An initial <strong>Span ID</strong> (example: <code>S1</code>)</li>
</ul>

<pre>
TRACE-ID=T123
SPAN-ID=S1
</pre>

---

<h3>Step 2: Order Service Processes the Request</h3>

<p>
The Order Service creates a span representing its internal processing.
Once completed, the span is placed into an
<strong>asynchronous in-memory queue</strong>.
</p>

<pre>
TRACE-ID=T123 [OrderService] Order created for userId=55
</pre>

---

<h3>Step 3: Request Propagates to Payment Service</h3>

<p>
When Order Service calls the Payment Service, Sleuth automatically propagates
the tracing information via request headers:
</p>

<ul>
  <li><strong>Trace ID: T123</strong></li>
  <li><strong>Parent Span ID: S1</strong></li>
</ul>

<p>
The Payment Service:
</p>

<ul>
  <li>Does <strong>not</strong> create a new Trace ID</li>
  <li>Creates a new Span ID (example: <code>S2</code>)</li>
  <li>Links the span to its parent (<code>S1</code>)</li>
</ul>

<pre>
TRACE-ID=T123
SPAN-ID=S2
PARENT-SPAN-ID=S1
</pre>

---

<h3>Step 4: Payment Service Completes Its Work</h3>

<p>
After processing, the Payment Service completes its span and places it into the
in-memory queue managed by Sleuth.
</p>

<pre>
TRACE-ID=T123 [PaymentService] Payment timeout userId=55
</pre>

---

<h3>Step 5: Zipkin Exporter Sends Spans</h3>

<p>
The <strong>Zipkin Exporter</strong> asynchronously picks completed spans from
the in-memory queue and sends them to the <strong>Zipkin backend</strong>.
</p>

<p>
This asynchronous export ensures that tracing does not impact application
performance.
</p>

---

<h3>Step 6: Zipkin Backend Builds the Trace</h3>

<p>
The Zipkin backend receives spans from all services and stitches them together
using:
</p>

<ul>
  <li>Trace ID</li>
  <li>Span ID</li>
  <li>Parent Span ID</li>
</ul>

<p>
This creates a <strong>tree-like visualization</strong> that shows:
</p>

<ul>
  <li>Which service called which service</li>
  <li>How much time each service took</li>
  <li>Where errors or delays occurred</li>
</ul>

<p>
Using tools like <strong>Zipkin UI</strong> or <strong>Grafana</strong>, engineers
can easily analyze and debug distributed systems.
</p>






